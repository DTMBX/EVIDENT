<!-- Terminal Command Line Interface -->
<div class="terminal-widget" id="terminalWidget" style="display: none;">
  <div class="terminal-container">
    <div class="terminal-header">
      <div class="terminal-title">
        <span class="terminal-icon">⌘</span>
        BarberX Terminal
        <span class="terminal-subtitle">v2.0.0</span>
      </div>
      <div class="terminal-actions">
        <button class="terminal-action" onclick="clearTerminal()" title="Clear">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="3 6 5 6 21 6"/>
            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
          </svg>
        </button>
        <button class="terminal-action" onclick="toggleFullscreen()" title="Fullscreen">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/>
          </svg>
        </button>
        <button class="terminal-action" onclick="closeTerminal()" title="Close">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"/>
            <line x1="6" y1="6" x2="18" y2="18"/>
          </svg>
        </button>
      </div>
    </div>
    
    <div class="terminal-output" id="terminalOutput">
      <div class="terminal-line">
        <span class="terminal-prompt">Welcome to BarberX Terminal</span>
      </div>
      <div class="terminal-line">
        <span class="terminal-text">Type 'help' for available commands</span>
      </div>
      <div class="terminal-line">
        <span class="terminal-text">━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</span>
      </div>
    </div>

    <div class="terminal-input-line">
      <span class="terminal-prompt">barberx@legal:~$</span>
      <input 
        type="text" 
        class="terminal-input" 
        id="terminalInput"
        autocomplete="off"
        spellcheck="false"
        onkeydown="handleTerminalKeydown(event)"
      />
    </div>
  </div>
</div>

<!-- Terminal Toggle Button (Ctrl+`) -->
<button class="terminal-toggle-btn" id="terminalToggleBtn" onclick="toggleTerminal()" title="Terminal (Ctrl+`)">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <polyline points="4 17 10 11 4 5"/>
    <line x1="12" y1="19" x2="20" y2="19"/>
  </svg>
</button>

<style>
.terminal-toggle-btn {
  position: fixed;
  bottom: 2rem;
  left: 2rem;
  width: 56px;
  height: 56px;
  border-radius: 12px;
  background: #0d1117;
  border: 2px solid #30363d;
  color: #58a6ff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  transition: all 0.3s;
  z-index: 9998;
}

.terminal-toggle-btn:hover {
  background: #161b22;
  border-color: #58a6ff;
  transform: translateY(-4px);
  box-shadow: 0 6px 20px rgba(88, 166, 255, 0.3);
}

.terminal-toggle-btn svg {
  width: 24px;
  height: 24px;
}

.terminal-widget {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 50vh;
  background: #0d1117;
  border-top: 2px solid #30363d;
  z-index: 9997;
  animation: slideUpTerminal 0.3s ease-out;
}

.terminal-widget.fullscreen {
  height: 100vh;
  top: 0;
}

@keyframes slideUpTerminal {
  from {
    transform: translateY(100%);
  }
  to {
    transform: translateY(0);
  }
}

.terminal-container {
  height: 100%;
  display: flex;
  flex-direction: column;
  font-family: 'Courier New', 'Consolas', monospace;
}

.terminal-header {
  padding: 0.75rem 1rem;
  background: #161b22;
  border-bottom: 1px solid #30363d;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.terminal-title {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  color: #c9d1d9;
  font-weight: 600;
  font-size: 0.875rem;
}

.terminal-icon {
  font-size: 1.25rem;
}

.terminal-subtitle {
  color: #8b949e;
  font-size: 0.75rem;
  font-weight: 400;
}

.terminal-actions {
  display: flex;
  gap: 0.5rem;
}

.terminal-action {
  width: 32px;
  height: 32px;
  border-radius: 6px;
  border: none;
  background: transparent;
  color: #8b949e;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s;
}

.terminal-action:hover {
  background: #21262d;
  color: #c9d1d9;
}

.terminal-action svg {
  width: 18px;
  height: 18px;
}

.terminal-output {
  flex: 1;
  overflow-y: auto;
  padding: 1rem;
  color: #c9d1d9;
  font-size: 0.875rem;
  line-height: 1.6;
}

.terminal-line {
  margin-bottom: 0.25rem;
  display: flex;
  gap: 0.5rem;
}

.terminal-prompt {
  color: #58a6ff;
  font-weight: 600;
}

.terminal-text {
  color: #c9d1d9;
}

.terminal-error {
  color: #f85149;
}

.terminal-success {
  color: #3fb950;
}

.terminal-warning {
  color: #d29922;
}

.terminal-input-line {
  padding: 0.75rem 1rem;
  background: #010409;
  border-top: 1px solid #30363d;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.terminal-input {
  flex: 1;
  background: transparent;
  border: none;
  color: #c9d1d9;
  font-family: inherit;
  font-size: 0.875rem;
  outline: none;
}

.terminal-input::selection {
  background: #58a6ff;
  color: #0d1117;
}

/* Scrollbar */
.terminal-output::-webkit-scrollbar {
  width: 8px;
}

.terminal-output::-webkit-scrollbar-track {
  background: #010409;
}

.terminal-output::-webkit-scrollbar-thumb {
  background: #30363d;
  border-radius: 4px;
}

.terminal-output::-webkit-scrollbar-thumb:hover {
  background: #484f58;
}

/* Command syntax highlighting */
.cmd-keyword {
  color: #ff7b72;
}

.cmd-string {
  color: #a5d6ff;
}

.cmd-number {
  color: #79c0ff;
}

.cmd-comment {
  color: #8b949e;
  font-style: italic;
}
</style>

<script>
let terminalHistory = [];
let historyIndex = -1;
let currentDirectory = '~';

const commands = {
  help: {
    description: 'Show available commands',
    usage: 'help [command]',
    execute: (args) => {
      if (args.length > 0) {
        const cmd = commands[args[0]];
        if (cmd) {
          return [
            { text: `${args[0]} - ${cmd.description}`, type: 'text' },
            { text: `Usage: ${cmd.usage}`, type: 'text' }
          ];
        }
        return [{ text: `Unknown command: ${args[0]}`, type: 'error' }];
      }
      
      const helpLines = [
        { text: 'Available Commands:', type: 'success' },
        { text: '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', type: 'text' }
      ];
      
      Object.entries(commands).forEach(([name, cmd]) => {
        helpLines.push({ text: `  ${name.padEnd(15)} - ${cmd.description}`, type: 'text' });
      });
      
      helpLines.push({ text: '', type: 'text' });
      helpLines.push({ text: 'Keyboard Shortcuts:', type: 'success' });
      helpLines.push({ text: '  Ctrl+`          - Toggle terminal', type: 'text' });
      helpLines.push({ text: '  ↑/↓             - Command history', type: 'text' });
      helpLines.push({ text: '  Tab             - Auto-complete', type: 'text' });
      helpLines.push({ text: '  Ctrl+C          - Cancel current command', type: 'text' });
      
      return helpLines;
    }
  },
  
  clear: {
    description: 'Clear terminal screen',
    usage: 'clear',
    execute: () => {
      document.getElementById('terminalOutput').innerHTML = '';
      return [];
    }
  },
  
  ls: {
    description: 'List analyses',
    usage: 'ls [--recent | --all]',
    execute: async (args) => {
      try {
        const response = await fetch('/api/analyses');
        const data = await response.json();
        
        const lines = [
          { text: 'Your Analyses:', type: 'success' },
          { text: '━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━', type: 'text' }
        ];
        
        if (data.analyses && data.analyses.length > 0) {
          data.analyses.forEach(analysis => {
            const status = analysis.status === 'completed' ? '✓' : analysis.status === 'analyzing' ? '⟳' : '○';
            lines.push({
              text: `  ${status} ${analysis.id.padEnd(25)} ${analysis.filename.substring(0, 30)}`,
              type: analysis.status === 'completed' ? 'success' : 'text'
            });
          });
        } else {
          lines.push({ text: '  No analyses found', type: 'warning' });
        }
        
        return lines;
      } catch (error) {
        return [{ text: `Error: ${error.message}`, type: 'error' }];
      }
    }
  },
  
  analyze: {
    description: 'View analysis details',
    usage: 'analyze <analysis_id>',
    execute: async (args) => {
      if (args.length === 0) {
        return [{ text: 'Error: Please provide an analysis ID', type: 'error' }];
      }
      
      try {
        const response = await fetch(`/api/analysis/${args[0]}`);
        const data = await response.json();
        
        return [
          { text: `Analysis: ${data.filename}`, type: 'success' },
          { text: `Status: ${data.status}`, type: 'text' },
          { text: `Case: ${data.case_number || 'N/A'}`, type: 'text' },
          { text: `Created: ${new Date(data.created_at).toLocaleString()}`, type: 'text' },
          { text: `Speakers: ${data.total_speakers || 'N/A'}`, type: 'text' },
          { text: `Segments: ${data.total_segments || 'N/A'}`, type: 'text' },
          { text: `Discrepancies: ${data.total_discrepancies || 'N/A'}`, type: 'text' }
        ];
      } catch (error) {
        return [{ text: `Error: Analysis not found`, type: 'error' }];
      }
    }
  },
  
  download: {
    description: 'Download analysis report',
    usage: 'download <analysis_id> <format>',
    execute: (args) => {
      if (args.length < 2) {
        return [
          { text: 'Error: Please provide analysis ID and format', type: 'error' },
          { text: 'Usage: download <id> <json|txt|md>', type: 'text' }
        ];
      }
      
      const [id, format] = args;
      const validFormats = ['json', 'txt', 'md'];
      
      if (!validFormats.includes(format)) {
        return [{ text: `Error: Invalid format. Use: ${validFormats.join(', ')}`, type: 'error' }];
      }
      
      window.location.href = `/api/analysis/${id}/report/${format}`;
      return [{ text: `Downloading ${format} report...`, type: 'success' }];
    }
  },
  
  search: {
    description: 'Search transcripts',
    usage: 'search <query>',
    execute: async (args) => {
      if (args.length === 0) {
        return [{ text: 'Error: Please provide a search query', type: 'error' }];
      }
      
      const query = args.join(' ');
      return [
        { text: `Searching for: "${query}"`, type: 'text' },
        { text: 'Search functionality coming soon...', type: 'warning' }
      ];
    }
  },
  
  status: {
    description: 'Check system status',
    usage: 'status',
    execute: async () => {
      try {
        const response = await fetch('/api/health');
        const data = await response.json();
        
        return [
          { text: 'System Status:', type: 'success' },
          { text: `  Status: ${data.status}`, type: 'text' },
          { text: `  Uptime: ${data.uptime || 'N/A'}`, type: 'text' },
          { text: `  Database: Connected`, type: 'success' }
        ];
      } catch (error) {
        return [{ text: 'Error: Unable to fetch status', type: 'error' }];
      }
    }
  },
  
  echo: {
    description: 'Echo text to terminal',
    usage: 'echo <text>',
    execute: (args) => {
      return [{ text: args.join(' '), type: 'text' }];
    }
  },
  
  date: {
    description: 'Show current date and time',
    usage: 'date',
    execute: () => {
      return [{ text: new Date().toString(), type: 'text' }];
    }
  },
  
  whoami: {
    description: 'Show current user',
    usage: 'whoami',
    execute: () => {
      const user = '{{ current_user.email if current_user.is_authenticated else "anonymous" }}';
      return [{ text: user, type: 'text' }];
    }
  }
};

function toggleTerminal() {
  const widget = document.getElementById('terminalWidget');
  const isVisible = widget.style.display !== 'none';
  
  if (isVisible) {
    widget.style.display = 'none';
  } else {
    widget.style.display = 'block';
    document.getElementById('terminalInput').focus();
  }
}

function closeTerminal() {
  document.getElementById('terminalWidget').style.display = 'none';
}

function clearTerminal() {
  document.getElementById('terminalOutput').innerHTML = '';
}

function toggleFullscreen() {
  const widget = document.getElementById('terminalWidget');
  widget.classList.toggle('fullscreen');
}

async function handleTerminalKeydown(event) {
  const input = event.target;
  
  if (event.key === 'Enter') {
    const command = input.value.trim();
    if (command) {
      terminalHistory.push(command);
      historyIndex = terminalHistory.length;
      await executeCommand(command);
      input.value = '';
    }
  } else if (event.key === 'ArrowUp') {
    event.preventDefault();
    if (historyIndex > 0) {
      historyIndex--;
      input.value = terminalHistory[historyIndex];
    }
  } else if (event.key === 'ArrowDown') {
    event.preventDefault();
    if (historyIndex < terminalHistory.length - 1) {
      historyIndex++;
      input.value = terminalHistory[historyIndex];
    } else {
      historyIndex = terminalHistory.length;
      input.value = '';
    }
  } else if (event.key === 'Tab') {
    event.preventDefault();
    // Auto-complete logic here
  } else if (event.ctrlKey && event.key === 'c') {
    event.preventDefault();
    addTerminalLine('', 'text');
    input.value = '';
  }
}

async function executeCommand(command) {
  const output = document.getElementById('terminalOutput');
  
  // Add command to output
  const commandLine = document.createElement('div');
  commandLine.className = 'terminal-line';
  commandLine.innerHTML = `
    <span class="terminal-prompt">barberx@legal:${currentDirectory}$</span>
    <span class="terminal-text">${escapeHtml(command)}</span>
  `;
  output.appendChild(commandLine);
  
  // Parse command
  const parts = command.split(' ');
  const cmd = parts[0];
  const args = parts.slice(1);
  
  // Execute command
  if (commands[cmd]) {
    try {
      const result = await commands[cmd].execute(args);
      if (result && result.length > 0) {
        result.forEach(line => {
          addTerminalLine(line.text, line.type);
        });
      }
    } catch (error) {
      addTerminalLine(`Error: ${error.message}`, 'error');
    }
  } else {
    addTerminalLine(`Command not found: ${cmd}. Type 'help' for available commands.`, 'error');
  }
  
  // Scroll to bottom
  output.scrollTop = output.scrollHeight;
}

function addTerminalLine(text, type = 'text') {
  const output = document.getElementById('terminalOutput');
  const line = document.createElement('div');
  line.className = 'terminal-line';
  
  const span = document.createElement('span');
  span.className = `terminal-${type}`;
  span.textContent = text;
  
  line.appendChild(span);
  output.appendChild(line);
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Keyboard shortcut: Ctrl+` to toggle terminal
document.addEventListener('keydown', (event) => {
  if (event.ctrlKey && event.key === '`') {
    event.preventDefault();
    toggleTerminal();
  }
});
</script>
